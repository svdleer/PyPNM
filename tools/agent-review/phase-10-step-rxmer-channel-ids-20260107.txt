# FILE: src/pypnm/api/routes/common/classes/common_endpoint_classes/common_req_resp.py
# SPDX-License-Identifier: Apache-2.0
# Copyright (c) 2025-2026 Maurice Garcia

from __future__ import annotations

from pydantic import BaseModel, Field, field_validator

from pypnm.api.routes.advance.common.operation_state import OperationState
from pypnm.api.routes.common.classes.common_endpoint_classes.common.enum import (
    AnalysisType,
    OutputType,
)
from pypnm.api.routes.common.classes.common_endpoint_classes.schema.base_snmp import (
    SNMPConfig,
)
from pypnm.api.routes.common.service.status_codes import ServiceStatusCode
from pypnm.config.system_config_settings import SystemConfigSettings
from pypnm.lib.mac_address import MacAddress, MacAddressFormat
from pypnm.lib.matplot.manager import ThemeType
from pypnm.lib.types import ChannelId, InetAddressStr, IPv4Str, IPv6Str, MacAddressStr

default_mac: MacAddressStr = SystemConfigSettings.default_mac_address()
default_ip: InetAddressStr = SystemConfigSettings.default_ip_address()
default_tftp_ipv4: IPv4Str = SystemConfigSettings.bulk_tftp_ip_v4()
default_tftp_ipv6: IPv6Str = SystemConfigSettings.bulk_tftp_ip_v6()

class CommonOutput(BaseModel):
    type: OutputType = Field(default=OutputType.JSON, description="Desired output type for analysis results")

class TftpConfig(BaseModel):
    ipv4: IPv4Str | None = Field(default=default_tftp_ipv4, description="TFTP server IPv4 address")
    ipv6: IPv6Str | None = Field(default=default_tftp_ipv6, description="TFTP server IPv6 address")

class PnmCaptureConfig(BaseModel):
    channel_ids: list[ChannelId] | None = Field(
        default=None,
        description="Optional channel id list for targeted captures (empty or missing means all channels).",
    )

class PnmParameters(BaseModel):
    tftp: TftpConfig = Field(default_factory=TftpConfig, description="TFTP configuration")
    capture: PnmCaptureConfig = Field(default_factory=PnmCaptureConfig, description="Capture parameters")


class CableModemPnmConfig(BaseModel):
    mac_address: MacAddressStr    = Field(default=default_mac, description="MAC address of the cable modem")
    ip_address: InetAddressStr    = Field(default=default_ip, description="Inet address of the cable modem")
    pnm_parameters: PnmParameters = Field(description="PNM parameters such as TFTP server configuration")
    snmp: SNMPConfig              = Field(description="SNMP configuration")

    @field_validator("mac_address")
    def validate_mac(cls, v: str) -> MacAddressStr:
        try:
            return MacAddress(v).mac_address
        except Exception as e:
            raise ValueError(f"Invalid MAC address: {v}, reason: ({e})") from e


class CommonMatPlotUiConfig(BaseModel):
    theme: ThemeType = Field(default="dark", description="Matplotlib theme selection for plot rendering")

class CommonMatPlotConfigRequest(BaseModel):
    ui: CommonMatPlotUiConfig = Field(default=CommonMatPlotUiConfig(), description="Matplotlib UI configuration for plot generation")

class CommonFileSearchRequest(BaseModel):
    mac_address: MacAddressStr = Field(description="MAC address of the cable modem")

    @field_validator("mac_address")
    def validate_mac(cls, v: MacAddressStr) -> MacAddressStr:
        try:
            return MacAddress(v).to_mac_format(MacAddressFormat.COLON)
        except Exception as e:
            raise ValueError(f"Invalid MAC address: {v}, reason: ({e})") from e

class CommonRequest(BaseModel):
    cable_modem: CableModemPnmConfig = Field(description="Cable modem configuration for basic PNM operations")


class CommonAnalysisType(BaseModel):
    type: int = Field(description="Analysis type to perform, implementation-specific integer value")

class CommonMultiAnalysisRequest(BaseModel):
    cable_modem: CableModemPnmConfig = Field(description="Cable modem configuration")
    analysis: CommonAnalysisType     = Field(description="Analysis type to perform")


class CommonAnalysisRequest(BaseModel):
    cable_modem: CableModemPnmConfig = Field(description="Cable modem configuration")
    analysis: CommonAnalysisType     = Field(description="Analysis type or mode to perform")
    output: CommonOutput             = Field(description="Output type control: JSON or archive")


class CommonSingleCaptureAnalysisType(BaseModel):
    type: AnalysisType              = Field(default=AnalysisType.BASIC, description="Analysis type to perform")
    output: CommonOutput            = Field(description="Output format selection for single capture analysis")
    plot: CommonMatPlotConfigRequest = Field(description="Plot configuration for single capture analysis")


class CommonSingleCaptureAnalysisRequest(BaseModel):
    cable_modem: CableModemPnmConfig          = Field(description="Cable modem configuration")
    analysis: CommonSingleCaptureAnalysisType = Field(description="Single capture analysis configuration")


class CommonResponse(BaseModel):
    mac_address: MacAddressStr                                      = Field(default=default_mac, description="MAC address of the cable modem")
    status: ServiceStatusCode | OperationState | str | None = Field(default="success", description="Operation status code or state")
    message: str | None                                          = Field(default=None, description="Additional information or error details")

    @field_validator("mac_address")
    def validate_mac(cls, v: str) -> MacAddressStr:
        try:
            return MacAddress(v).mac_address
        except Exception as e:
            raise ValueError(f"Invalid MAC address: {v}, reason: ({e})") from e


class CommonAnalysisResponse(CommonResponse):
    """Basic analysis response model."""
    pass

# FILE: src/pypnm/api/routes/docs/pnm/ds/ofdm/rxmer/router.py
# SPDX-License-Identifier: Apache-2.0
# Copyright (c) 2025-2026 Maurice Garcia

from __future__ import annotations

import logging
from pathlib import Path
from typing import Any, cast

from fastapi import APIRouter
from starlette.responses import FileResponse

from pypnm.api.routes.basic.rxmer_analysis_rpt import (
    AnalysisRptMatplotConfig,
    RxMerAnalysisReport,
)
from pypnm.api.routes.common.classes.analysis.analysis import Analysis, AnalysisType
from pypnm.api.routes.common.classes.common_endpoint_classes.common.enum import (
    OutputType,
)
from pypnm.api.routes.common.classes.common_endpoint_classes.schemas import (
    PnmAnalysisResponse,
    PnmSingleCaptureRequest,
)
from pypnm.api.routes.common.classes.common_endpoint_classes.snmp.schemas import (
    SnmpResponse,
)
from pypnm.api.routes.common.extended.common_measure_schema import (
    DownstreamOfdmParameters,
)
from pypnm.api.routes.common.classes.file_capture.file_type import FileType
from pypnm.api.routes.common.classes.operation.cable_modem_precheck import (
    CableModemServicePreCheck,
)
from pypnm.api.routes.common.extended.common_messaging_service import MessageResponse
from pypnm.api.routes.common.extended.common_process_service import CommonProcessService
from pypnm.api.routes.common.service.status_codes import ServiceStatusCode
from pypnm.api.routes.docs.pnm.ds.ofdm.rxmer.service import CmDsOfdmRxMerService
from pypnm.api.routes.docs.pnm.files.service import PnmFileService
from pypnm.docsis.cable_modem import CableModem
from pypnm.docsis.cm_snmp_operation import DocsPnmCmDsOfdmRxMerEntry
from pypnm.lib.dict_utils import DictGenerate
from pypnm.lib.fastapi_constants import FAST_API_RESPONSE
from pypnm.lib.inet import Inet
from pypnm.lib.mac_address import MacAddress
from pypnm.lib.types import ChannelId, InetAddressStr, MacAddressStr


class RxMerRouter:
    def __init__(self) -> None:
        prefix = "/docs/pnm/ds/ofdm"
        self.base_endpoint = "/rxMer"
        self.router = APIRouter(
            prefix=prefix, tags=["PNM Operations - Downstream OFDM RxMER"])
        self.logger = logging.getLogger(f'RxMerRouter.{self.base_endpoint.strip("/")}')
        self.__routes()

    def __routes(self) -> None:
        @self.router.post(
            f"{self.base_endpoint}/getCapture",
            summary="Get RxMER PNM Capture File",
            response_model=None,
            responses=FAST_API_RESPONSE,)
        async def get_capture(request: PnmSingleCaptureRequest) -> SnmpResponse | PnmAnalysisResponse | FileResponse:
            """
            Capture Downstream OFDM RxMER Per-Subcarrier Values.

            [API Guide](https://github.com/PyPNMApps/PyPNM/blob/main/docs/api/fast-api/single/ds/ofdm/rxmer.md)

            """
            mac: MacAddressStr = request.cable_modem.mac_address
            ip: InetAddressStr = request.cable_modem.ip_address
            community: str = request.cable_modem.snmp.snmp_v2c.community
            tftp_server_ipv4 = Inet(cast(InetAddressStr, request.cable_modem.pnm_parameters.tftp.ipv4))
            tftp_server_ipv6 = Inet(cast(InetAddressStr, request.cable_modem.pnm_parameters.tftp.ipv6))
            tftp_servers = (tftp_server_ipv4, tftp_server_ipv6)

            self.logger.info(f"Starting RxMER measurement for MAC: {mac}, IP: {ip}")

            cm = CableModem(mac_address=MacAddress(mac), inet=Inet(ip), write_community=community)

            status, msg = await CableModemServicePreCheck(
                cable_modem=cm, validate_ofdm_exist=True).run_precheck()

            if status != ServiceStatusCode.SUCCESS:
                self.logger.error(msg)
                return SnmpResponse(mac_address=mac, status=status, message=msg)

            service: CmDsOfdmRxMerService = CmDsOfdmRxMerService(cm, tftp_servers)
            channel_ids = request.cable_modem.pnm_parameters.capture.channel_ids
            interface_parameters = self._resolve_interface_parameters(channel_ids)
            msg_rsp: MessageResponse = await service.set_and_go(interface_parameters=interface_parameters)

            if msg_rsp.status != ServiceStatusCode.SUCCESS:
                err = "Unable to complete RxMER measurement."
                return SnmpResponse(mac_address=mac, message=err, status=msg_rsp.status)

            measurement_stats:list[DocsPnmCmDsOfdmRxMerEntry] = \
                cast(list[DocsPnmCmDsOfdmRxMerEntry], await service.getPnmMeasurementStatistics())

            cps = CommonProcessService(msg_rsp)
            msg_rsp = cps.process()

            analysis = Analysis(AnalysisType.BASIC, msg_rsp)

            if request.analysis.output.type == OutputType.JSON:
                payload: dict[str, Any] = cast(dict[str, Any], analysis.get_results())

                # Clean up payload by removing unneeded or redundant sections
                DictGenerate.pop_keys_recursive(payload, ["pnm_header", "modulations", "snr_db_values"])
                primative = msg_rsp.payload_to_dict('primative')
                DictGenerate.pop_keys_recursive(primative, ["device_details", "modulation_statistics"])
                payload.update({str(k): v for k, v in primative.items()})
                payload.update(DictGenerate.models_to_nested_dict(measurement_stats, 'measurement_stats',))

                return PnmAnalysisResponse(
                    mac_address =   mac,
                    status      =   ServiceStatusCode.SUCCESS,
                    data        =   payload,)

            elif request.analysis.output.type == OutputType.ARCHIVE:
                theme = request.analysis.plot.ui.theme
                plot_config = AnalysisRptMatplotConfig(theme = theme)
                analysis_rpt = RxMerAnalysisReport(analysis, plot_config)
                rpt: Path = cast(Path, analysis_rpt.build_report())
                return PnmFileService().get_file(FileType.ARCHIVE, rpt.name)

            else:
                return PnmAnalysisResponse(
                    mac_address =   mac,
                    status      =   ServiceStatusCode.INVALID_OUTPUT_TYPE,
                    data        =   {},)

    @staticmethod
    def _resolve_interface_parameters(
        channel_ids: list[ChannelId] | None,
    ) -> DownstreamOfdmParameters | None:
        if not channel_ids:
            return None
        return DownstreamOfdmParameters(channel_id=list(channel_ids))


# Required for dynamic auto-registration
router = RxMerRouter().router

# FILE: docs/api/fast-api/single/ds/ofdm/rxmer.md
# PNM Operations - Downstream OFDM RxMER

Deep Visibility Into Downstream OFDM RxMER At The Subcarrier Level.

## Overview

[`CmDsOfdmRxMer`](https://github.com/PyPNMApps/PyPNM/blob/main/src/pypnm/pnm/parser/CmDsOfdmRxMer.py) validates that the input PNM payload is an RxMER file, unpacks header fields, decodes per-subcarrier RxMER in quarter-dB steps, and provides a typed model (`CmDsOfdmRxMerModel`) with statistics and Shannon-based modulation metrics.

## Endpoint

`POST /docs/pnm/ds/ofdm/rxMer/getCapture`

## Request

Refer to [Common → Request](../../../common/request.md).
**Deltas (Analysis-only additions):** the request accepts optional `analysis`, `analysis.output`, and `analysis.plot.ui` controls.

### Delta Table

| JSON path                | Type   | Allowed values / format | Default   | Description                                                                                                                                                                                    |
| ------------------------ | ------ | ----------------------- | --------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `analysis.type`          | string | `"basic"`               | `"basic"` | Selects the analysis mode used during capture processing.                                                                                                                                      |
| `analysis.output.type`   | string | `"json"`, `"archive"`   | `"json"`  | Output format. **`json`** returns an inline body under `data` (`analysis`, `primative`, `measurement_stats`). **`archive`** returns a downloadable ZIP (CSV exports and Matplotlib PNG plots). |
| `analysis.plot.ui.theme` | string | `"light"`, `"dark"`     | `"dark"`  | Theme hint for plot generation (colors, grid, ticks). Does not affect raw metrics/CSV.                                                                                                         |
| `pnm_parameters.capture.channel_ids` | array(int) | Channel IDs | omitted | Optional list of OFDM channel IDs to capture. Omitted or empty means all available channels. |

## Notes

* When `analysis.output.type = "archive"`, the HTTP response body is the file (no `data` JSON payload).
* The `primative` section is a normalized representation of the raw PNM file with added statistics (e.g., mean, std, kurtosis).
* The `measurement_stats` section summarizes one-shot SNMP statistics collected at capture-time (useful for dashboards).
* When `pnm_parameters.capture.channel_ids` is omitted or empty, RxMER captures all available OFDM channels.

### Example Request

```json
{
  "cable_modem": {
    "mac_address": "aa:bb:cc:dd:ee:ff",
    "ip_address": "192.168.0.100",
    "pnm_parameters": {
      "tftp": {
        "ipv4": "192.168.0.10",
        "ipv6": "2001:db8::10"
      },
      "capture": {
        "channel_ids": [193, 194]
      }
    },
    "snmp": {
      "snmpV2C": {
        "community": "private"
      }
    }
  },
  "analysis": {
    "type": "basic",
    "output": { "type": "json" },
    "plot": { "ui": { "theme": "dark" } }
  }
}
```

## Response

Standard envelope with payload under `data`.

### When `output.type = "json"`

```json
"output": { "type": "json" }
```

#### Abbreviated Example

```json
{
  "mac_address": "aabbccddeeff",
  "status": 0,
  "message": null,
  "data": {
    "analysis": [
      {
        "device_details": {
          "system_description": {
            "HW_REV": "1.0",
            "VENDOR": "LANCity",
            "BOOTR": "NONE",
            "SW_REV": "1.0.0",
            "MODEL": "LCPET-3"
          }
        },
        "mac_address": "aa:bb:cc:dd:ee:ff",
        "channel_id": 193,
        "subcarrier_spacing": 50000,
        "first_active_subcarrier_index": 148,
        "subcarrier_zero_frequency": 251600000,
        "carrier_values": {
          "carrier_status_map": { "exclusion": "0", "clipped": "1", "normal": "2" },
          "magnitude_unit": "dB",
          "frequency_unit": "Hz",
          "carrier_count": 3800,
          "magnitude": [],
          "frequency": [],
          "carrier_status": []
        },
        "regression": { "slope": [] },
        "modulation_statistics": {
          "snr_db_values": [],
          "bits_per_symbol": [],
          "modulations": [],
          "snr_db_min": [],
          "supported_modulation_counts": {
            "qam_2": 3800, "qam_4": 3800, "qam_8": 3800, "qam_16": 3798,
            "qam_32": 3787, "qam_64": 3778, "qam_128": 3762, "qam_256": 3469,
            "qam_512": 2733, "qam_1024": 2362, "qam_2048": 2019, "qam_4096": 1467,
            "qam_8192": 883, "qam_16384": 60, "qam_32768": 0, "qam_65536": 0
          }
        }
      }
    ],
    "primative": [
      {
        "status": "SUCCESS",
        "pnm_header": {
          "file_type": "PNN",
          "file_type_version": 4,
          "major_version": 1,
          "minor_version": 0,
          "capture_time": 1761238473
        },
        "channel_id": 193,
        "mac_address": "aa:bb:cc:dd:ee:ff",
        "subcarrier_zero_frequency": 251600000,
        "first_active_subcarrier_index": 148,
        "subcarrier_spacing": 50000,
        "data_length": 3800,
        "occupied_channel_bandwidth": 190000000,
        "value_units": "dB",
        "values": [],
        "signal_statistics": {
          "mean": 32.80559210526316,
          "median": 34.0,
          "std": 6.398852563006556,
          "variance": 40.94531412309557,
          "power": 1117.1521875,
          "peak_to_peak": 32.0,
          "mean_abs_deviation": 5.666524757617728,
          "skewness": -0.25361308425026813,
          "kurtosis": 1.883937273853999,
          "crest_factor": 1.3089464730216689,
          "zero_crossing_rate": 0.0,
          "zero_crossings": 0
        }
      }
    ],
    "measurement_stats": [
      {
        "index": 3,
        "channel_id": 3,
        "entry": {
          "docsPnmCmDsOfdmRxMerFileEnable": true,
          "docsPnmCmDsOfdmRxMerFileName": "ds_ofdm_rxmer_per_subcar_aabbccddeeff_193_1761514136.bin",
          "docsPnmCmDsOfdmRxMerMeasStatus": "sample_ready",
          "docsPnmCmDsOfdmRxMerPercentile": 0.02,
          "docsPnmCmDsOfdmRxMerMean": 33.21,
          "docsPnmCmDsOfdmRxMerStdDev": 6.29,
          "docsPnmCmDsOfdmRxMerThrVal": 0.93,
          "docsPnmCmDsOfdmRxMerThrHighestFreq": 319500000
        }
      }
    ]
  }
}
```

### When `output.type = "archive"`

```json
"output": { "type": "archive" }
```

The response is a downloadable ZIP file containing:

* CSV export of RxMER per subcarrier.
* Matplotlib PNG plots of RxMER vs. Subcarrier Index.

| DARK                                                                                  | Light                                                                       | Description                                |
| ------------------------------------------------------------------------------------- | --------------------------------------------------------------------------- | ------------------------------------------ |
| [RxMER (Ch 193)](./images/rxmer/dark_1761343516_193_rxmer.png)                        | [RxMER (Ch 193)](./images/rxmer/light_193_rxmer.png)                        | RxMER vs. Subcarrier Index — Channel 193   |
| [Modulation Counts (Ch 193)](./images/rxmer/dark_1761343516_193_modulation_count.png) | [Modulation Counts (Ch 193)](./images/rxmer/light_193_modulation_count.png) | Modulation Counts — Channel 193            |
| [RxMER (Ch 194)](./images/rxmer/dark_1761343516_194_rxmer.png)                        | [RxMER (Ch 194)](./images/rxmer/light_194_rxmer.png)                        | RxMER vs. Subcarrier Index — Channel 194   |
| [Modulation Counts (Ch 194)](./images/rxmer/dark_194_modulation_count.png)            | [Modulation Counts (Ch 194)](./images/rxmer/light_194_modulation_count.png) | Modulation Counts — Channel 194            |
| [RxMER (Ch 195)](./images/rxmer/dark_195_rxmer.png)                                   | [RxMER (Ch 195)](./images/rxmer/light_195_rxmer.png)                        | RxMER vs. Subcarrier Index — Channel 195   |
| [Modulation Counts (Ch 195)](./images/rxmer/dark_195_modulation_count.png)            | [Modulation Counts (Ch 195)](./images/rxmer/light_195_modulation_count.png) | Modulation Counts — Channel 195            |
| [RxMER (Ch 196)](./images/rxmer/dark_196_rxmer.png)                                   | [RxMER (Ch 196)](./images/rxmer/light_196_rxmer.png)                        | RxMER vs. Subcarrier Index — Channel 196   |
| [Modulation Counts (Ch 196)](./images/rxmer/dark_196_modulation_count.png)            | [Modulation Counts (Ch 196)](./images/rxmer/light_196_modulation_count.png) | Modulation Counts — Channel 196            |
| [RxMER (Ch 197)](./images/rxmer/dark_197_rxmer.png)                                   | [RxMER (Ch 197)](./images/rxmer/light_197_rxmer.png)                        | RxMER vs. Subcarrier Index — Channel 197   |
| [Modulation Counts (Ch 197)](./images/rxmer/dark_1761343516_197_modulation_count.png) | [Modulation Counts (Ch 197)](./images/rxmer/light_197_modulation_count.png) | Modulation Counts — Channel 197            |
| [Signal Aggregate](./images/rxmer/dark_1761343516_signal_aggregate.png)               | [Signal Aggregate](./images/rxmer/light_signal_aggregate.png)               | Aggregate Signal Statistics (All Channels) |

## Field Tables

**Payload: `data.analysis[]`**

| Field                         | Type         | Description                                    |
| ----------------------------- | ------------ | ---------------------------------------------- |
| device_details.*              | object       | System descriptor captured at analysis time.   |
| mac_address                   | string       | MAC address (`aa:bb:cc:dd:ee:ff` format).      |
| channel_id                    | int          | OFDM downstream channel ID.                    |
| subcarrier_spacing            | int (Hz)     | Subcarrier spacing.                            |
| first_active_subcarrier_index | int          | Index of first active subcarrier.              |
| subcarrier_zero_frequency     | int (Hz)     | Subcarrier 0 frequency.                        |
| carrier_values.*              | object       | Frequency-aligned magnitude and status arrays. |
| regression.slope              | array(float) | Optional regression slope values.              |
| modulation_statistics.*       | object       | Shannon-based metrics and counts by QAM order. |

**Payload: `data.primative[]`**

| Field                         | Type         | Description                                       |
| ----------------------------- | ------------ | ------------------------------------------------- |
| status                        | string       | Result for this capture (e.g., `SUCCESS`).        |
| pnm_header.*                  | object       | PNM file header (type, version, capture time).    |
| channel_id                    | int          | Channel ID.                                       |
| mac_address                   | string       | MAC address.                                      |
| subcarrier_zero_frequency     | int (Hz)     | Channel zero frequency.                           |
| first_active_subcarrier_index | int          | Index of first active subcarrier.                 |
| subcarrier_spacing            | int (Hz)     | Subcarrier spacing.                               |
| data_length                   | int          | Number of RxMER samples.                          |
| occupied_channel_bandwidth    | int (Hz)     | Occupied bandwidth.                               |
| value_units                   | string       | Units for `values` (e.g., `dB`).                  |
| values                        | array(float) | RxMER values per subcarrier.                      |
| signal_statistics.*           | object       | Aggregate statistics (mean, std, variance, etc.). |

**Payload: `data.measurement_stats[]`**

Summarized SNMP snapshot for each channel at capture time.

| Field                                    | Type     | Description                                              |
| ---------------------------------------- | -------- | -------------------------------------------------------- |
| index                                    | int      | SNMP table row index (per device).                       |
| channel_id                               | int      | OFDM downstream channel ID.                              |
| entry.docsPnmCmDsOfdmRxMerFileEnable     | boolean  | Whether CM capture-to-file was enabled.                  |
| entry.docsPnmCmDsOfdmRxMerFileName       | string   | Device-side filename of the PNM RxMER sample.            |
| entry.docsPnmCmDsOfdmRxMerMeasStatus     | string   | Measurement state (e.g., `sample_ready`).                |
| entry.docsPnmCmDsOfdmRxMerPercentile     | number   | Percentile requested for percentile capture (0.00-1.00). |
| entry.docsPnmCmDsOfdmRxMerMean           | number   | Mean RxMER (dB) reported by CM.                          |
| entry.docsPnmCmDsOfdmRxMerStdDev         | number   | Standard deviation (dB).                                 |
| entry.docsPnmCmDsOfdmRxMerThrVal         | number   | Threshold value dependent on vendor implementation.      |
| entry.docsPnmCmDsOfdmRxMerThrHighestFreq | int (Hz) | Highest frequency associated with threshold metric.      |

# FILE: tests/test_rxmer_channel_ids.py
# SPDX-License-Identifier: Apache-2.0
# Copyright (c) 2026 Maurice Garcia

from __future__ import annotations

import pytest

from pypnm.api.routes.common.extended.common_measure_schema import DownstreamOfdmParameters
from pypnm.api.routes.common.extended.common_measure_service import CommonMeasureService
from pypnm.api.routes.docs.pnm.ds.ofdm.rxmer.router import RxMerRouter
from pypnm.api.routes.common.service.status_codes import ServiceStatusCode
from pypnm.lib.types import ChannelId, InterfaceIndex
from pypnm.lib.inet import Inet
from pypnm.pnm.data_type.pnm_test_types import DocsPnmCmCtlTest


class _FakeCableModem:
    def __init__(self) -> None:
        self._mac = "aa:bb:cc:dd:ee:ff"
        self._inet = "192.168.0.100"

    @property
    def get_mac_address(self) -> str:
        return self._mac

    @property
    def get_inet_address(self) -> str:
        return self._inet

    async def getDocsIf31CmDsOfdmChannelIdIndexStack(self) -> list[tuple[InterfaceIndex, ChannelId]]:
        return [
            (InterfaceIndex(1), ChannelId(1)),
            (InterfaceIndex(2), ChannelId(2)),
            (InterfaceIndex(3), ChannelId(3)),
        ]

    async def getDocsIf31CmUsOfdmaChannelIdIndexStack(self) -> list[tuple[InterfaceIndex, ChannelId]]:
        return []

    async def getIfTypeIndex(self, *_args: object, **_kwargs: object) -> list[InterfaceIndex]:
        return [InterfaceIndex(1)]


@pytest.mark.asyncio
async def test_rxmer_channel_ids_absent_preserves_all_channels() -> None:
    modem = _FakeCableModem()
    service = CommonMeasureService(
        DocsPnmCmCtlTest.DS_OFDM_RXMER_PER_SUBCAR,
        modem,
        (Inet("0.0.0.0"), Inet("::")),
    )
    status, idx_channel = await service._get_indexes_via_pnm_test_type(None)
    assert status == ServiceStatusCode.SUCCESS
    assert idx_channel == [
        (InterfaceIndex(1), ChannelId(1)),
        (InterfaceIndex(2), ChannelId(2)),
        (InterfaceIndex(3), ChannelId(3)),
    ]


@pytest.mark.asyncio
async def test_rxmer_channel_ids_filter_scope() -> None:
    modem = _FakeCableModem()
    service = CommonMeasureService(
        DocsPnmCmCtlTest.DS_OFDM_RXMER_PER_SUBCAR,
        modem,
        (Inet("0.0.0.0"), Inet("::")),
    )
    params = DownstreamOfdmParameters(channel_id=[ChannelId(2), ChannelId(3)])
    status, idx_channel = await service._get_indexes_via_pnm_test_type(params)
    assert status == ServiceStatusCode.SUCCESS
    assert idx_channel == [
        (InterfaceIndex(2), ChannelId(2)),
        (InterfaceIndex(3), ChannelId(3)),
    ]


def test_rxmer_router_resolves_channel_ids() -> None:
    router = RxMerRouter()
    assert router._resolve_interface_parameters(None) is None
    assert router._resolve_interface_parameters([]) is None
    params = router._resolve_interface_parameters([ChannelId(4)])
    assert isinstance(params, DownstreamOfdmParameters)
    assert params.channel_id == [ChannelId(4)]

